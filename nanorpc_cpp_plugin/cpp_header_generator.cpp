#include <string>

#include "google\protobuf\compiler\code_generator.h"
#include "google\protobuf\compiler\cpp\cpp_generator.h"
#include "google\protobuf\compiler\plugin.h"
#include "google\protobuf\compiler\plugin.pb.h"
#include "google\protobuf\io\coded_stream.h"
#include "google\protobuf\io\printer.h"
#include "google\protobuf\io\zero_copy_stream.h"
#include "google\protobuf\io\zero_copy_stream_impl_lite.h"
#include "google\protobuf\wrappers.pb.h"

#include "rpc_proto/rpc_types.pb.h"

#include "generator_utils.h"
#include "code_model.h"

namespace pb = google::protobuf;
namespace pbc = google::protobuf::compiler;


std::string GetPropertySignature(const code_model::MethodModel *method,
                                 bool setter) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    const code_model::TypeModel &type = setter ? method->arguments().front().type() :
      method->return_type();

    vars["method_name"] = method->name();
    vars["type_name"] = type.name();

    if (type.is_reference_type()) {
      if (setter)
        printer.Print(vars, "void set_$method_name$(const $type_name$ &value)");
      else
        printer.Print(vars, "void get_$method_name$($type_name$ *value) const");
    }
    else {
      if (setter)
        printer.Print(vars, "void set_$method_name$($type_name$ value)");
      else
        printer.Print(vars, "$type_name$ get_$method_name$() const");
    }
  }

  return output;
}

std::string GetMethodSignature(const code_model::MethodModel *method) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["method_name"] = method->name();
    vars["output_type_name"] = method->return_type().name();

    if (method->return_type().is_reference_type())
      printer.Print(vars, "void $method_name$(");
    else
      printer.Print(vars, "$output_type_name$ $method_name$(");

    for (size_t i = 0; i < method->arguments().size(); ++i) {
      const auto &arg = method->arguments()[i];

      std::map<std::string, std::string> vars;

      vars["arg_type"] = arg.type().name();
      vars["const"] = arg.type().is_reference_type() ? "const " : "";
      vars["reference"] = arg.type().is_reference_type() ? "&" : "";
      vars["arg_name"] = arg.name();
      printer.Print(vars, "$const$$arg_type$ $reference$$arg_name$");
      if ((i + 1) < method->arguments().size())
        printer.Print(", ");
    }

    if (method->return_type().is_reference_type()) {
      if (method->arguments().size() > 0)
        printer.Print(", ");
      printer.Print(vars, "$output_type_name$ *out__)");
    }
    else {    
      printer.Print(")");
    }
  }

  return output;
}

std::string GetHeaderPrologue(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());
    vars["filename_base"] = StripProto(file->name());

    /* clang-format off */
    printer.Print(vars, "// Generated by the nanorpc protobuf plugin.\n");
    printer.Print(vars, "// If you make any local change, they will be lost.\n");
    printer.Print(vars, "// source: $filename$\n");
    printer.Print(vars, "#ifndef NANORPC_$filename_identifier$__INCLUDED\n");
    printer.Print(vars, "#define NANORPC_$filename_identifier$__INCLUDED\n");
    printer.Print(vars, "\n");
    printer.Print(vars, "#include \"$filename_base$.pb.h\"\n");
    printer.Print(vars, "#include \"rpc_stub.hpp\"\n");
    printer.Print(vars, "#include \"rpc_object_manager.hpp\"\n");
    printer.Print(vars, "\n");
    /* clang-format on */

    if (!file->package().empty()) {
      std::vector<std::string> parts = tokenize(file->package(), ".");

      for (auto &part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "namespace $part$ {\n");
      }

      printer.Print(vars, "\n");
    }
  }
  return output;
}

std::string GetInterfaceDefinitions(const pb::FileDescriptor *file, const std::vector<code_model::ServiceModel> &models) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    for (const auto &service_model : models) {
      vars["service_name"] = service_model.name();

      /* clang-format off */
      printer.Print(vars, "class $service_name$ {\n");
      printer.Print(vars, "public:\n");
      printer.Indent();
      printer.Print(vars, "virtual ~$service_name$() {}\n\n");

      for (const auto &method_model : service_model.methods()) {
        vars["method_name"] = method_model.name();
        if (method_model.is_property()) {

          if (method_model.getter() != nullptr)
            vars["getter_signature"] = GetPropertySignature(method_model.getter(), false);
          if (method_model.setter() != nullptr)
            vars["setter_signature"] = GetPropertySignature(method_model.setter(), true);

          printer.Print(vars, "virtual $getter_signature$ = 0;\n");
          printer.Print(vars, "virtual $setter_signature$ = 0;\n");
        }
        else {
          vars["method_signature"] = GetMethodSignature(&method_model);
          printer.Print(vars, "virtual $method_signature$ = 0;\n");
        }
      }

      printer.Outdent();
      printer.Print(vars, "};\n\n");
      /* clang-format on */
    }
  }
  return output;
}

std::string GetStubDeclarations(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    for (int i = 0; i < file->service_count(); ++i) {
      const auto service = file->service(i);
      vars["service_name"] = service->name();

      // clang-format off
      printer.Print(vars, "class $service_name$_Stub : public nanorpc2::IRpcStub {\n");
      printer.Print(vars, "public:\n");
      printer.Indent();
      printer.Print(vars, "explicit $service_name$_Stub(nanorpc2::IRpcObjectManager* object_manager, $service_name$* impl)\n");
      printer.Print(vars, "    : object_manager_(object_manager), impl_(impl) {}\n\n");
      printer.Print(vars, "const char *GetInterfaceName() const;\n");
      printer.Print(vars, "void CallMethod(const nanorpc2::RpcCall &rpc_call, nanorpc2::RpcResult *rpc_result);\n\n");
      printer.Outdent();
      printer.Print(vars, "private:\n");
      printer.Indent();
      printer.Print(vars, "nanorpc2::IRpcObjectManager* object_manager_;\n");
      printer.Print(vars, "$service_name$* impl_;\n");
      printer.Outdent();
      printer.Print(vars, "};\n\n");
      // clang-format on
    }
  }
  return output;
}

std::string GetHeaderEpilogue(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());

    if (!file->package().empty()) {
      std::vector<std::string> parts = tokenize(file->package(), ".");

      for (auto &part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "}  // namespace $part$\n");
      }
      printer.Print(vars, "\n");
    }

    printer.Print(vars, "\n");
    printer.Print(vars, "#endif  // NANORPC_$filename_identifier$__INCLUDED\n");
  }
  return output;
}

std::string GetSourcePrologue(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());
    vars["filename_base"] = StripProto(file->name());

    /* clang-format off */
    printer.Print(vars, "// Generated by the nanorpc protobuf plugin.\n");
    printer.Print(vars, "// If you make any local change, they will be lost.\n");
    printer.Print(vars, "// source: $filename$\n");
    printer.Print(vars, "\n");
    printer.Print(vars, "#include \"$filename_base$.nanorpc.pb.h\"\n");
    printer.Print(vars, "\n");
    /* clang-format on */

    if (!file->package().empty()) {
      std::vector<std::string> parts = tokenize(file->package(), ".");

      for (auto &part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "namespace $part$ {\n");
      }

      printer.Print(vars, "\n");
    }
  }
  return output;
}

void GenerateStubImplementation(pb::io::Printer &printer, const code_model::ServiceModel &service) {
  std::map<std::string, std::string> vars;

  /* clang-format off */
  printer.Indent();

  for (size_t i = 0; i < service.methods().size(); ++i) {
    const auto &method = service.methods()[i];
    vars["method_name"] = method.name();
    vars["return_type"] = method.return_type().name();
    vars["return_pb_type"] = method.return_type().pb_name();

    printer.Print(vars, "if (rpc_call.method() == \"$method_name$\") {\n");
    printer.Indent();

    // Define return type variable
    if (!method.return_type().is_void())
      printer.Print(vars, "$return_type$ out__;\n");

    // Define argument variables
    for (size_t j = 0; j < method.arguments().size(); ++j) {
      const auto &arg = method.arguments()[j];
      vars["arg_name"] = arg.name();
      vars["arg_type"] = arg.type().name();
      printer.Print(vars, "$arg_type$ $arg_name$;\n");
    }

    // TODO: Deserialize argument variables
    if (method.arguments().size() > 0) {
      if (method.is_arglist()) {
        vars["arglist_typename"] = method.arglist_typename();
        printer.Print(vars, "$arglist_typename$ args__;\n");
        // BUG: This is incorrect if argument is a value type.
        // In order to parse it out one need to declare a PB wrapper first,
        // parse and then extract the value out of the wrapper.
        printer.Print(vars, "args__.ParseFromString(rpc_call.call_data());\n");

        // TODO: We can avoid declaring argument variable for value
        // types and instead pass them directly via message accessor, but
        // declaring them makes it easier to debug and they probably will
        // be optimized away anyways.
        for (size_t j = 0; j < method.arguments().size(); ++j) {
          const auto &arg = method.arguments()[j];
          vars["arg_name"] = arg.name();
          vars["arg_type"] = arg.type().name();

          if (arg.type().is_reference_type())
            printer.Print(vars, "args__.$arg_name$_value(&$arg_name$);\n");
          else
            printer.Print(vars, "$arg_name$ = args__.$arg_name$();\n");
        }
      }
      else {
        // Non-wrappers always reference types.
        vars["arg_type"] = method.arguments().front().type().pb_name();
        // Already declared with 'value' name (as it is a part of model).
        // printer.Print(vars, "$arg_type$ arg__;\n");
        printer.Print(vars, "value.ParseFromString(rpc_call.call_data());\n");
      }
    }

    // Return for value types
    if (!method.return_type().is_void() && !method.return_type().is_reference_type())
      printer.Print(vars, "out__ = ");

    // Call interface method
    printer.Print(vars, "impl_->$method_name$(");

    // Specify arguments
    for (size_t j = 0; j < method.arguments().size(); ++j) {
      const auto &arg = method.arguments()[j];
      vars["arg_name"] = arg.name();
      vars["arg_type"] = arg.type().name();
      printer.Print(vars, "$arg_name$");

      if ((j + 1) < method.arguments().size())
        printer.Print(vars, ", ");
    }

    // Specify return by pointer argument (for reference types)
    if (!method.return_type().is_void() && method.return_type().is_reference_type())
      printer.Print(vars, ", &out__");

    printer.Print(vars, ");\n");

    // Define result wrapper variable, wrap and serialize the result
    printer.Print(vars, "$return_pb_type$ out_pb__;\n");
    printer.Print(vars, "out_pb__.set_value(out__);\n");
    printer.Print(vars, "out_pb__.SerializeToString(rpc_result->mutable_call_result()->mutable_value());\n");
    printer.Outdent();
    printer.Print(vars, "}");

    if ((i + 1) < service.methods().size())
      printer.Print(vars, " else ");
  }

  printer.Print(vars, "\n\n");
  printer.Outdent();
  /* clang-format on */
}


std::string GetStubDefinitions(const pb::FileDescriptor *file, const std::vector<code_model::ServiceModel> &models) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    for (const auto &service : models) {
      vars["service_name"] = service.name();
      vars["service_full_name"] = service.full_name();

      // clang-format off
      printer.Print(vars, "const char *$service_name$::GetInterfaceName() const {\n");
      printer.Indent();
      printer.Print(vars, "return \"$service_full_name$\";\n");
      printer.Outdent();
      printer.Print(vars, "}\n\n");

      printer.Print(vars, "void $service_name$::CallMethod(const nanorpc2::RpcCall &rpc_call, nanorpc2::RpcResult *rpc_result) {\n");
      GenerateStubImplementation(printer, service);
      printer.Print(vars, "}\n\n");
      // clang-format on
    }
  }
  return output;
}

std::string GetSourceEpilogue(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());

    if (!file->package().empty()) {
      std::vector<std::string> parts = tokenize(file->package(), ".");

      for (auto &part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "}  // namespace $part$\n");
      }
      printer.Print(vars, "\n");
    }

    printer.Print(vars, "\n");
  }
  return output;
}
