#include <string>
#include "google\protobuf\io\coded_stream.h"
#include "google\protobuf\io\zero_copy_stream.h"
#include "google\protobuf\io\zero_copy_stream_impl_lite.h"
#include "google\protobuf\io\printer.h"
#include "google\protobuf\compiler\plugin.h"
#include "google\protobuf\compiler\plugin.pb.h"
#include "google\protobuf\compiler\code_generator.h"
#include "google\protobuf\compiler\cpp\cpp_generator.h"

namespace pb = google::protobuf;
namespace pbc = google::protobuf::compiler;

inline bool StripSuffix(std::string *filename, const std::string &suffix) {
  if (filename->length() >= suffix.length()) {
    size_t suffix_pos = filename->length() - suffix.length();
    if (filename->compare(suffix_pos, std::string::npos, suffix) == 0) {
      filename->resize(filename->size() - suffix.size());
      return true;
    }
  }

  return false;
}

inline std::string StripProto(std::string filename) {
  if (!StripSuffix(&filename, ".protodevel")) {
    StripSuffix(&filename, ".proto");
  }
  return filename;
}

class NanoRpcCppGenerator : public pbc::CodeGenerator {
public:
  bool Generate(const pb::FileDescriptor* file,
                        const std::string& parameter,
                        pbc::GeneratorContext* context,
                        std::string* error) const override;
};

bool NanoRpcCppGenerator::Generate(const pb::FileDescriptor* file,
              const std::string& parameter,
              pbc::GeneratorContext* context,
              std::string* error) const {

  std::string file_name = StripProto(file->name());

  std::string header_code;
  pb::io::StringOutputStream output_stream(&header_code);
  pb::io::Printer printer(&output_stream, '$');
  std::map<std::string, std::string> vars;
  printer.Print(vars, "// Generated by the nanorpc protobuf plugin.\n");
  for (int i = 0; i < file->service_count(); ++i) {
    vars["service_name"] = file->service(i)->name();
    printer.Print(vars, "// class $service_name$ {};\n");
  }

  std::unique_ptr<pb::io::ZeroCopyOutputStream> header_output(context->Open(file_name + ".nanorpc.pb.h"));
  pb::io::CodedOutputStream header_coded_out(header_output.get());
  header_coded_out.WriteRaw(header_code.data(), header_code.size());

  std::string source_code = "// test cpp";
  std::unique_ptr<pb::io::ZeroCopyOutputStream> source_output(
    context->Open(file_name + ".nanorpc.pb.cc"));
  pb::io::CodedOutputStream source_coded_out(source_output.get());
  source_coded_out.WriteRaw(source_code.data(), source_code.size());

  return true;
}


int main(int argc, char **argv) {
  NanoRpcCppGenerator generator;
  return pbc::PluginMain(argc, argv, &generator);
}

