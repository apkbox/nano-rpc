<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
				version="1.0"
				xml:space="default"
				xmlns:xmlidl="urn:odgs-oce-net:schemas-nano-rpc-idl" >
	<xsl:param name="_guard_name" />
	<xsl:param name="_template_name" />
	<xsl:param name="_document_name" />
	<xsl:param name="_output_type_header" />

	<xsl:output method="text" encoding="utf-8" />

	<xsl:variable name="typemap" select="document('cpp-types.xml')" />
	<xsl:include href="common.xsl" />

	<xsl:template match="/xmlidl:idl">
		<xsl:text>// Generated by the IdlCompiler. DO NOT EDIT!&#10;</xsl:text>
		<xsl:text>// source: </xsl:text><xsl:value-of select="$_document_name"/><xsl:text>&#10;</xsl:text>
		<xsl:text>// template: </xsl:text><xsl:value-of select="$_template_name"/><xsl:text>&#10;</xsl:text>

		<xsl:text>&#10;</xsl:text>

		<xsl:variable name="guard" select="concat( $_guard_name, '__' )" />
		<xsl:text>#if !defined( </xsl:text><xsl:value-of select="$guard" />
		<xsl:text> )&#10;#define </xsl:text><xsl:value-of select="$guard" />
		<xsl:text>&#10;&#10;</xsl:text>

		<xsl:text><![CDATA[#include "]]></xsl:text>
		<xsl:value-of select="$_output_type_header" />
		<xsl:text><![CDATA["]]></xsl:text>
		<xsl:text>&#10;&#10;</xsl:text>

		<xsl:text>#include &lt;string&gt;</xsl:text>
		<xsl:text>&#10;&#10;</xsl:text>

		<xsl:if test="boolean(@namespace)">
			<xsl:text>namespace </xsl:text>
			<xsl:value-of select="@namespace" />
			<xsl:text> {&#10;&#10;</xsl:text>
		</xsl:if>
		
		<xsl:apply-templates select="xmlidl:interfaces/xmlidl:interface" />

		<xsl:if test="boolean(@namespace)">
			<xsl:text>} // namespace&#10;&#10;</xsl:text>
		</xsl:if>
		
		<xsl:text>#endif // </xsl:text><xsl:value-of select="$guard" />
		<xsl:text>&#10;&#10;</xsl:text>
	</xsl:template>

	<xsl:template match="xmlidl:interface" >
		<xsl:text>class </xsl:text><xsl:value-of select="@name" />
		<xsl:text>&#10;{&#10;</xsl:text>
		<xsl:text>public:&#10;</xsl:text>

		<xsl:call-template name="generate_destructor" />
		
		<xsl:apply-templates select="xmlidl:property" />
		<xsl:apply-templates select="xmlidl:method" />
		
		<xsl:text>};&#10;&#10;&#10;</xsl:text>
	</xsl:template>

	<xsl:template name="generate_destructor" >
		<!-- virtual ~Interface() {}-->
		<xsl:text>&#09;virtual ~</xsl:text><xsl:value-of select="@name" /><xsl:text>() {}&#10;&#10;</xsl:text>
	</xsl:template>

	<xsl:template match="xmlidl:property" >
		<!-- virtual SIMPLE_TYPE get_Property() const = 0; -->
		<!-- virtual void get_Property( COMPLEX_TYPE *value ) const = 0; -->
		<xsl:text>&#09;virtual </xsl:text>
		<xsl:call-template name="declare_return_type"/>
		<xsl:text> get_</xsl:text><xsl:value-of select="@name" />
		<xsl:text>(</xsl:text>
		<xsl:call-template name="declare_return_argument" />
		<xsl:text>) const = 0;</xsl:text>
		<xsl:text>&#10;</xsl:text>

		<!-- 
			This is a not schema-aware processor, so we cannot rely on datatype of 
			attributes and elements declared in schema!
		-->
		<xsl:if test="count(@readonly)=0 or @readonly='false' or @readonly='no' or  @readonly='0'">
			<!-- virtual void set_Property( const TYPE & ) = 0; -->
			<xsl:text>&#09;virtual void</xsl:text>
			<xsl:text> set_</xsl:text><xsl:value-of select="@name" />
			<xsl:text>( const </xsl:text><xsl:call-template name="map_type" /><xsl:text> &amp; ) = 0;</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
	</xsl:template>

	<xsl:template match="xmlidl:method" >
		<xsl:text>&#09;virtual </xsl:text>
		<xsl:call-template name="declare_method_return_type"/>
		<xsl:text> </xsl:text>
		<xsl:value-of select="@name" />
		<xsl:text>(</xsl:text>
		<xsl:apply-templates select="xmlidl:arguments" />
		<xsl:if test="count( xmlidl:returns ) != 0" >
			<xsl:call-template name="declare_return_argument">
				<xsl:with-param name="type" select="xmlidl:returns/@type"/>
			</xsl:call-template>
		</xsl:if>
		<xsl:text>) = 0;</xsl:text>
		<xsl:text>&#10;</xsl:text>
	</xsl:template>
	
	<xsl:template name="declare_method_return_type" >
		<xsl:choose>
			<xsl:when test="count( xmlidl:returns ) != 0" >
				<xsl:call-template name="declare_return_type" >
					<xsl:with-param name="type" select="xmlidl:returns/@type"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>void</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="declare_return_type" >
		<xsl:param name="type" select="@type"/>
		<xsl:choose>
			<xsl:when test="$type='bool' or $type='int' or $type='long' or $type='double'">
				<xsl:call-template name="map_type">
					<xsl:with-param name="type_to_map" select="$type"/>
				</xsl:call-template>
			</xsl:when>
			
			<xsl:when test="count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0">
				<xsl:value-of select="$type"/>
			</xsl:when>

			<xsl:when test="count( /xmlidl:idl/xmlidl:interfaces/xmlidl:interface[@name=$type] ) != 0">
				<xsl:value-of select="$type"/>
				<xsl:text>*</xsl:text>
			</xsl:when>

			<xsl:otherwise>
				<xsl:text>void</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	
	<xsl:template name="declare_return_argument" >
		<xsl:param name="type" select="@type"/>
		<xsl:if test="not( $type='bool' or $type='int' or $type='long' or $type='double' or
						count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0 or
						count( /xmlidl:idl/xmlidl:interfaces/xmlidl:interface[@name=$type] ) != 0 )">
			<xsl:if test="count( xmlidl:arguments/xmlidl:argument ) != 0">
				<xsl:text>, </xsl:text>
			</xsl:if>
			<xsl:call-template name="map_type" >
				<xsl:with-param name="type_to_map" select="$type" />
			</xsl:call-template>
			<xsl:text> *return_value</xsl:text>
		</xsl:if>
	</xsl:template>


	<xsl:template match="xmlidl:argument" >
		<xsl:call-template name="create_argument" />
		<xsl:if test="position() != last()">
			<xsl:text>, </xsl:text>
		</xsl:if>
	</xsl:template>


	<xsl:template name="create_argument" >
		<xsl:variable name="type" select="@type"/>
		<xsl:choose>
			<xsl:when test="@type='bool' or @type='int' or @type='long' or @type='double'">
				<xsl:call-template name="map_type" />
				<xsl:text> </xsl:text>
				<xsl:value-of select="@name" />
			</xsl:when>

			<xsl:when test="count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0">
				<xsl:value-of select="@type" />
				<xsl:text> </xsl:text>
				<xsl:value-of select="@name" />
			</xsl:when>

			<xsl:when test="@type = 'string'">
				<xsl:text>const </xsl:text><xsl:call-template name="map_type" />
				<xsl:text> &amp;</xsl:text>
				<xsl:value-of select="@name" />
			</xsl:when>

			<xsl:otherwise>
				<xsl:text>const </xsl:text><xsl:value-of select="@type" />
				<xsl:text> &amp;</xsl:text>
				<xsl:value-of select="@name" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

</xsl:stylesheet>
