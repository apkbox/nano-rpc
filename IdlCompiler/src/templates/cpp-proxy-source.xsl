<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
				version="1.0"
				xml:space="default"
				xmlns:xmlidl="urn:odgs-oce-net:schemas-nano-rpc-idl" >
	<xsl:param name="_guard_name" />
	<xsl:param name="_template_name" />
	<xsl:param name="_document_name" />
	<xsl:param name="_output_proxy_header" />

	<xsl:output method="text" encoding="utf-8" />

	<xsl:variable name="typemap" select="document('cpp-types.xml')" />
	<xsl:include href="common.xsl" />

	<xsl:template match="/xmlidl:idl">
		<xsl:text>// Generated by the IdlCompiler. DO NOT EDIT!&#10;</xsl:text>
		<xsl:text>// source: </xsl:text><xsl:value-of select="$_document_name"/><xsl:text>&#10;</xsl:text>
		<xsl:text>// template: </xsl:text><xsl:value-of select="$_template_name"/><xsl:text>&#10;</xsl:text>

		<xsl:text>&#10;</xsl:text>
		
		<xsl:text><![CDATA[#include "]]></xsl:text>
		<xsl:value-of select="$_output_proxy_header" />
		<xsl:text><![CDATA["]]></xsl:text>
		<xsl:text>&#10;&#10;</xsl:text>
		<xsl:text><![CDATA[#include <exception>]]>&#10;</xsl:text>
		<xsl:text><![CDATA[#include <string>]]>&#10;</xsl:text>
		<xsl:text>&#10;&#10;</xsl:text>

		<xsl:if test="boolean(@namespace)">
			<xsl:text>namespace </xsl:text>
			<xsl:value-of select="@namespace" />
			<xsl:text> {&#10;&#10;</xsl:text>
		</xsl:if>

		<xsl:apply-templates select="xmlidl:interfaces/xmlidl:interface" />

		<xsl:if test="boolean(@namespace)">
			<xsl:text>} // namespace&#10;&#10;</xsl:text>
		</xsl:if>
		
		<xsl:text>&#10;&#10;</xsl:text>
	</xsl:template>

	<xsl:template match="xmlidl:interface" >
		<xsl:if test ="not( @source='true' or @source='yes' or @source='1' )">
			<xsl:value-of select="@name"/>
			<xsl:text>_Proxy::~</xsl:text>
			<xsl:value-of select="@name"/>
			<xsl:text>_Proxy()&#10;{&#10;</xsl:text>

			<!--
				if( object_id_ != 0 ) {
					try {
						NanoRpc::RpcMessage rpc_message;
						rpc_message.mutable_call()->set_service( "NanoRpc.ObjectManagerService" );
						rpc_message.mutable_call()->set_method( "Delete" );
						rpc_message.mutable_call()->add_parameters()->set_uint32_value( object_id_ );
						client_->Send( rpc_message );
					}
					catch( ... ) {
					}
				}
			-->
			<xsl:text>&#09;<![CDATA[if( object_id_ != 0 ) {]]>&#10;</xsl:text>
			<xsl:text>&#09;&#09;<![CDATA[try {]]>&#10;</xsl:text>
			<xsl:text>&#09;&#09;&#09;<![CDATA[NanoRpc::RpcMessage rpc_message;]]>&#10;</xsl:text>
			<xsl:text>&#09;&#09;&#09;<![CDATA[rpc_message.mutable_call()->set_service( "NanoRpc.ObjectManagerService" );]]>&#10;</xsl:text>
			<xsl:text>&#09;&#09;&#09;<![CDATA[rpc_message.mutable_call()->set_method( "Delete" );]]>&#10;</xsl:text>
			<xsl:text>&#09;&#09;&#09;<![CDATA[rpc_message.mutable_call()->add_parameters()->set_uint32_value( object_id_ );]]>&#10;</xsl:text>
			<xsl:text>&#09;&#09;&#09;<![CDATA[client_->Send( rpc_message );]]>&#10;</xsl:text>
			<xsl:text>&#09;&#09;<![CDATA[}]]>&#10;</xsl:text>
			<xsl:text>&#09;&#09;<![CDATA[catch( ... ) {]]>&#10;</xsl:text>
			<xsl:text>&#09;&#09;<![CDATA[}]]>&#10;</xsl:text>
			<xsl:text>&#09;<![CDATA[}]]></xsl:text>
			
			<xsl:text>&#10;}&#10;&#10;&#10;</xsl:text>
		</xsl:if>

		<xsl:apply-templates select="xmlidl:property" />
		<xsl:apply-templates select="xmlidl:method" />
	</xsl:template>

	<xsl:template match="xmlidl:property" >
		<!-- SIMPLE_TYPE [classname]_Proxy::get_Property() const -->
		<!-- void [classname]_Proxy::get_Property( COMPLEX_TYPE *value ) const -->
		<xsl:call-template name="declare_return_type"/>
		<xsl:text> </xsl:text>
		<xsl:value-of select="../@name" />
		<xsl:text>_Proxy::get_</xsl:text>
		<xsl:value-of select="@name" />
		<xsl:text>(</xsl:text>
		<xsl:call-template name="declare_return_argument"/>
		<xsl:text>) const&#10;</xsl:text>
		<xsl:text>{&#10;</xsl:text>
		<xsl:apply-templates select="." mode="generate_get_property_body" />
		<xsl:text>}&#10;&#10;&#10;</xsl:text>

		<!-- 
			This is a not schema-aware processor, so we cannot rely on datatype of 
			attributes and elements declared in schema!
		-->
		<xsl:if test="count(@readonly)=0 or @readonly='false' or @readonly='no' or @readonly='0'">
			<!-- void [classname]_Proxy::set_Property( const TYPE & ) -->
			<xsl:text>void</xsl:text>
			<xsl:text> </xsl:text>
			<xsl:value-of select="../@name" />
			<xsl:text>_Proxy::set_</xsl:text>
			<xsl:value-of select="@name" />
			<xsl:text>( const </xsl:text>
			<xsl:call-template name="map_type" />
			<xsl:text> &amp;value )&#10;</xsl:text>
			<xsl:text>{&#10;</xsl:text>
			<xsl:apply-templates select="." mode="generate_set_property_body" />
			<xsl:text>}&#10;&#10;&#10;</xsl:text>
		</xsl:if>
	</xsl:template>

	<xsl:template match="xmlidl:method" >
		<xsl:call-template name="declare_method_return_type"/>
		<xsl:text> </xsl:text>
		<xsl:value-of select="../@name" />
		<xsl:text>_Proxy::</xsl:text>
		<xsl:value-of select="@name" />
		<xsl:text>(</xsl:text>
		<xsl:apply-templates select="xmlidl:arguments" />
		<xsl:if test="count( xmlidl:returns ) != 0" >
			<xsl:call-template name="declare_return_argument">
				<xsl:with-param name="type" select="xmlidl:returns/@type"/>
			</xsl:call-template>
		</xsl:if>
		<xsl:text>)&#10;</xsl:text>
		<xsl:text>{&#10;</xsl:text>

		<xsl:call-template name="serialize_arguments" />

		<xsl:choose>
			<xsl:when test ="../@source='true' or ../@source='yes' or ../@source='1'">
				<xsl:text>&#09;<![CDATA[sender_->Send( rpc_message );]]>&#10;</xsl:text>
			</xsl:when>

			<xsl:otherwise>
				<xsl:text>&#10;&#09;if( object_id_ != 0 )&#10;&#09;&#09;rpc_message.mutable_call()->set_object_id( object_id_ );&#10;</xsl:text>

				<xsl:text>&#10;&#09;NanoRpc::RpcResult rpc_result;&#10;</xsl:text>
				<xsl:text>&#09;<![CDATA[client_->SendWithReply( rpc_message, &rpc_result );]]>&#10;</xsl:text>
				<!-- TODO: Handle errorneous result -->
				<xsl:if test="count( xmlidl:returns ) != 0">
					<xsl:call-template name="deserialize_return_value">
						<xsl:with-param name="type" select="xmlidl:returns/@type"/>
					</xsl:call-template>
				</xsl:if>
			</xsl:otherwise>
		</xsl:choose>
		
		<xsl:text>}&#10;&#10;&#10;</xsl:text>
	</xsl:template>

	<xsl:template match="xmlidl:property" mode="generate_get_property_body" >
		<xsl:call-template name="serialize_arguments" />

		<xsl:text>&#10;&#09;if( object_id_ != 0 )&#10;&#09;&#09;rpc_message.mutable_call()->set_object_id( object_id_ );&#10;</xsl:text>

		<xsl:text>&#10;&#09;NanoRpc::RpcResult rpc_result;&#10;</xsl:text>
		<xsl:text>&#09;<![CDATA[client_->SendWithReply( rpc_message, &rpc_result );]]>&#10;</xsl:text>
		<!-- TODO: Handle errorneous result -->
		<xsl:call-template name="deserialize_return_value" />
	</xsl:template>
	
	<xsl:template match="xmlidl:property" mode="generate_set_property_body" >
		<!-- 
		Note that serialize arguments wouldn't create actual argument serialization here 
		because property does not have arguments node. This is a temporary shortcut to intitialize
		service and method fields.
		-->
		<xsl:call-template name="serialize_arguments" />
		<xsl:call-template name="serialize_value" >
			<xsl:with-param name="name" select="'value'"/>
		</xsl:call-template>
		
	</xsl:template>

	<xsl:template name="declare_method_return_type" >
		<xsl:choose>
			<xsl:when test="count( xmlidl:returns ) != 0" >
				<xsl:call-template name="declare_return_type" >
					<xsl:with-param name="type" select="xmlidl:returns/@type"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>void</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="declare_return_type" >
		<xsl:param name="type" select="@type"/>
		<xsl:choose>
			<xsl:when test="$type='bool' or $type='int' or $type='long' or $type='double'">
				<xsl:call-template name="map_type">
					<xsl:with-param name="type_to_map" select="$type"/>
				</xsl:call-template>
			</xsl:when>

			<xsl:when test="count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0">
				<xsl:value-of select="$type" />
			</xsl:when>

			<xsl:when test="count( /xmlidl:idl/xmlidl:interfaces/xmlidl:interface[@name=$type] ) != 0">
				<xsl:value-of select="$type" />
				<xsl:text>*</xsl:text>
			</xsl:when>

			<xsl:otherwise>
				<xsl:text>void</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="declare_return_argument" >
		<xsl:param name="type" select="@type"/>
		<xsl:if test="not( $type='bool' or $type='int' or $type='long' or $type='double' or
						count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0 or
						count( /xmlidl:idl/xmlidl:interfaces/xmlidl:interface[@name=$type] ) != 0 )">
			<xsl:if test="count( xmlidl:arguments/xmlidl:argument ) != 0">
				<xsl:text>, </xsl:text>
			</xsl:if>
			<xsl:call-template name="map_type" >
				<xsl:with-param name="type_to_map" select="$type" />
			</xsl:call-template>
			<xsl:text> *return_value</xsl:text>
		</xsl:if>
	</xsl:template>

	<xsl:template match="xmlidl:argument" >
		<xsl:call-template name="create_argument" />
		<xsl:if test="position() != last()">
			<xsl:text>, </xsl:text>
		</xsl:if>
	</xsl:template>

	<xsl:template name="create_argument" >
		<xsl:variable name="type" select="@type"/>
		<xsl:choose>
			<xsl:when test="@type='bool' or @type='int' or @type='long' or @type='double'">
				<xsl:call-template name="map_type" />
				<xsl:text> </xsl:text>
				<xsl:value-of select="@name" />
			</xsl:when>

			<xsl:when test="count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0">
				<xsl:value-of select="@type" />
				<xsl:text> </xsl:text>
				<xsl:value-of select="@name" />
			</xsl:when>

			<xsl:when test="@type = 'string'">
				<xsl:text>const </xsl:text>
				<xsl:call-template name="map_type" />
				<xsl:text> &amp;</xsl:text>
				<xsl:value-of select="@name" />
			</xsl:when>

			<xsl:otherwise>
				<xsl:text>const </xsl:text>
				<xsl:value-of select="@type" />
				<xsl:text> &amp;</xsl:text>
				<xsl:value-of select="@name" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="insert_service_name">
		<xsl:if test="boolean(../../../@namespace)">
			<xsl:value-of select="../../../@namespace"/>
			<xsl:text>.</xsl:text>
		</xsl:if>
		<xsl:value-of select="../@name"/>
	</xsl:template>

	<xsl:template name="serialize_arguments">
		<xsl:text>&#09;NanoRpc::RpcMessage rpc_message;&#10;</xsl:text>
		
		<!-- Set interface name. -->
		<xsl:choose>
			<xsl:when test ="../@source='true' or ../@source='yes' or ../@source='1'">
				<xsl:text>&#09;<![CDATA[rpc_message.mutable_call()->set_service( "]]></xsl:text>
				<xsl:call-template name="insert_service_name"/>
				<xsl:text><![CDATA[" );]]>&#10;</xsl:text>
			</xsl:when>

			<xsl:otherwise>
				<xsl:text>&#10;&#09;if( object_id_ != 0 ) {&#10;&#09;&#09;rpc_message.mutable_call()->set_object_id( object_id_ );&#10;&#09;}&#10;&#09;else {&#10;</xsl:text>
				<xsl:text>&#09;&#09;<![CDATA[rpc_message.mutable_call()->set_service( "]]></xsl:text>
				<xsl:call-template name="insert_service_name"/>
				<xsl:text><![CDATA[" );]]>&#10;&#09;}&#10;&#10;</xsl:text>
			</xsl:otherwise>
		</xsl:choose>

		<!-- Set method name. -->
		<xsl:text>&#09;<![CDATA[rpc_message.mutable_call()->set_method( "]]></xsl:text>
		<xsl:value-of select="@name"/>
		<xsl:text><![CDATA[" );]]>&#10;</xsl:text>

		<xsl:apply-templates select="xmlidl:arguments" mode="serialize_argument" />
	</xsl:template>

	<xsl:template match="xmlidl:argument" mode="serialize_argument" >
		<xsl:call-template name="serialize_value" />
	</xsl:template>

	<xsl:template name="serialize_value" >
		<xsl:param name="type" select="@type" />
		<xsl:param name="name" select="@name" />
		<xsl:choose>
			<xsl:when test="$type='bool'" >
				<xsl:text>&#09;</xsl:text>
				<xsl:text>rpc_message.mutable_call()->add_parameters()->set_bool_value( </xsl:text>
				<xsl:value-of select="$name"/>
				<xsl:text> );</xsl:text>
			</xsl:when>
			<xsl:when test="$type='int'" >
				<xsl:text>&#09;</xsl:text>
				<xsl:text>rpc_message.mutable_call()->add_parameters()->set_int32_value( </xsl:text>
				<xsl:value-of select="$name"/>
				<xsl:text> );</xsl:text>
			</xsl:when>
			<xsl:when test="$type='long'" >
				<xsl:text>&#09;</xsl:text>
				<xsl:text>rpc_message.mutable_call()->add_parameters()->set_int64_value( </xsl:text>
				<xsl:value-of select="$name"/>
				<xsl:text> );</xsl:text>
			</xsl:when>
			<xsl:when test="$type='double'" >
				<xsl:text>&#09;</xsl:text>
				<xsl:text>rpc_message.mutable_call()->add_parameters()->set_double_value( </xsl:text>
				<xsl:value-of select="$name"/>
				<xsl:text> );</xsl:text>
			</xsl:when>
			<xsl:when test="$type='string'" >
				<xsl:text>&#09;</xsl:text>
				<xsl:text>NanoRpc::WideToUtf8String( </xsl:text>
				<xsl:value-of select="$name"/>
				<xsl:text>, </xsl:text>
				<xsl:text>rpc_message.mutable_call()->add_parameters()->mutable_string_value() );</xsl:text>
			</xsl:when>
			<xsl:when test="count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0" >
				<xsl:text>&#09;</xsl:text>
				<xsl:text>rpc_message.mutable_call()->add_parameters()->set_int32_value( </xsl:text>
				<xsl:value-of select="$name"/>
				<xsl:text> );</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>&#09;</xsl:text>
				<xsl:text>std::string str;</xsl:text>
				<xsl:text>&#10;&#09;</xsl:text>
				<xsl:value-of select="$name"/>
				<xsl:text><![CDATA[.SerializeToString( &str );]]></xsl:text>
				<xsl:text>&#10;&#09;</xsl:text>
				<xsl:text>rpc_message.mutable_call()->add_parameters()->set_proto_value( str );</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>&#10;</xsl:text>
	</xsl:template>

	<xsl:template name="deserialize_return_value">
		<xsl:param name="type" select="@type" />
		
		<xsl:text>&#10;</xsl:text>

		<xsl:text>&#09;</xsl:text>
		<xsl:choose>
			<xsl:when test="$type='bool'" >
				<xsl:text>return </xsl:text>
				<xsl:text><![CDATA[rpc_result.call_result().bool_value();]]></xsl:text>
			</xsl:when>
			<xsl:when test="$type='int'" >
				<xsl:text>return </xsl:text>
				<xsl:text><![CDATA[rpc_result.call_result().int32_value();]]></xsl:text>
			</xsl:when>
			<xsl:when test="$type='long'" >
				<xsl:text>return </xsl:text>
				<xsl:text><![CDATA[rpc_result.call_result().int64_value();]]></xsl:text>
			</xsl:when>
			<xsl:when test="$type='double'" >
				<xsl:text>return </xsl:text>
				<xsl:text><![CDATA[rpc_result.call_result().double_value();]]></xsl:text>
			</xsl:when>
			<xsl:when test="$type='string'" >
				<xsl:text>NanoRpc::Utf8ToWideString( rpc_result.call_result().string_value(), return_value );</xsl:text>
			</xsl:when>
			<xsl:when test="count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0">
				<xsl:text>return </xsl:text>
				<xsl:text>static_cast&lt;</xsl:text>
				<xsl:value-of select="$type"/>
				<xsl:text>&gt;( </xsl:text>
				<xsl:text><![CDATA[rpc_result.call_result().int32_value() );]]></xsl:text>
			</xsl:when>
			<xsl:when test="count( /xmlidl:idl/xmlidl:interfaces/xmlidl:interface[@name=$type] ) != 0">
				<xsl:text>return new </xsl:text>
				<xsl:value-of select="$type"/>
				<xsl:text>_Proxy( client_, </xsl:text>
				<xsl:text><![CDATA[rpc_result.call_result().object_id_value() );]]></xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>return_value</xsl:text>
				<xsl:text><![CDATA[->ParseFromString( rpc_result.call_result().proto_value() );]]></xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>&#10;</xsl:text>
	</xsl:template>

</xsl:stylesheet>

