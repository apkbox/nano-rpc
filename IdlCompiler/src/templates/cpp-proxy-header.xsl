<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
				version="1.0"
				xml:space="default"
				xmlns:xmlidl="urn:odgs-oce-net:schemas-nano-rpc-idl" >
	<xsl:param name="_guard_name" />
	<xsl:param name="_template_name" />
	<xsl:param name="_document_name" />
	<xsl:param name="_output_interface_header" />

	<xsl:output method="text" encoding="utf-8" />

	<xsl:variable name="typemap" select="document('cpp-types.xml')" />
	<xsl:include href="common.xsl" />

	<xsl:template match="/xmlidl:idl">
		<xsl:text>// Generated by the IdlCompiler. DO NOT EDIT!&#10;</xsl:text>
		<xsl:text>// source: </xsl:text><xsl:value-of select="$_document_name"/><xsl:text>&#10;</xsl:text>
		<xsl:text>// template: </xsl:text><xsl:value-of select="$_template_name"/><xsl:text>&#10;</xsl:text>

		<xsl:text>&#10;</xsl:text>

		<xsl:variable name="guard" select="concat( $_guard_name, '__' )" />
		<xsl:text>#if !defined( </xsl:text><xsl:value-of select="$guard" />
		<xsl:text> )&#10;#define </xsl:text><xsl:value-of select="$guard" />
		<xsl:text>&#10;&#10;</xsl:text>

		<xsl:text>#include &lt;string&gt;</xsl:text>
		<xsl:text>&#10;&#10;</xsl:text>

		<xsl:text><![CDATA[#include "nano_rpc.hpp"]]>&#10;&#10;</xsl:text>

		<xsl:text><![CDATA[#include "]]></xsl:text>
		<xsl:value-of select="$_output_interface_header" />
		<xsl:text><![CDATA["]]></xsl:text>
		<xsl:text>&#10;&#10;</xsl:text>

		<xsl:if test="boolean(@namespace)">
			<xsl:text>namespace </xsl:text>
			<xsl:value-of select="@namespace" />
			<xsl:text> {&#10;&#10;</xsl:text>
		</xsl:if>

		<xsl:apply-templates select="xmlidl:interfaces/xmlidl:interface" />

		<xsl:if test="boolean(@namespace)">
			<xsl:text>} // namespace&#10;&#10;</xsl:text>
		</xsl:if>

		<xsl:text>#endif // </xsl:text>
		<xsl:value-of select="$guard" />
		<xsl:text>&#10;&#10;</xsl:text>
	</xsl:template>

	<xsl:template match="xmlidl:interface" >
		<!--
			class IInterface_Proxy : public IInterface
			{
			public:
			
			Then for source interfaces:
				explicit IInterface_Proxy( NanoRpc::IRpcMessageSender *sender ) : sender_( sender ) {}
				
			For ordinary interfaces:
				explicit IInterface_Proxy( NanoRpc::IRpcClient *client, NanoRpc::RpcObjectId object_id = 0 ) : client_( client ), object_id_( object_id ) {}
				virtual ~IInterface_Proxy();
		-->
		<xsl:text>class </xsl:text><xsl:value-of select="@name" />
		<xsl:text>_Proxy : public </xsl:text><xsl:value-of select="@name" />
		<xsl:text>&#10;{&#10;</xsl:text>
		<xsl:text>public:&#10;</xsl:text>

		<xsl:choose>
			<xsl:when test="@source='true' or @source='yes' or @source='1'">
				<xsl:text>&#09;explicit </xsl:text>
				<xsl:value-of select="@name" />
				<xsl:text>_Proxy( NanoRpc::IRpcMessageSender *sender ) : sender_( sender ) {}</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>&#09;explicit </xsl:text><xsl:value-of select="@name"/><xsl:text>_Proxy( NanoRpc::IRpcClient *client, NanoRpc::RpcObjectId object_id = 0 ) :&#10;&#09;&#09;client_( client ), object_id_( object_id )&#10;&#09;{&#10;&#09;}&#10;&#10;</xsl:text>
				<xsl:text>&#09;virtual ~</xsl:text><xsl:value-of select="@name"/><xsl:text>_Proxy();&#10;</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
		<xsl:text>&#10;&#10;</xsl:text>

		<xsl:apply-templates select="xmlidl:property" />
		<xsl:apply-templates select="xmlidl:method" />

		<xsl:text>&#10;</xsl:text>
		<!--
			For source interfaces:
			
			private:
				NanoRpc::IRpcMessageSender *sender_;
			};
			
			For normal interfaces:
			
			private:
				NanoRpc::IRpcClient *client_;
				NanoRpc::RpcObjectId object_id_;
			};
		-->
		<xsl:text>private:&#10;</xsl:text>
		<xsl:choose>
			<xsl:when test="@source='true' or @source='yes' or  @source='1'">
				<xsl:text>&#09;NanoRpc::IRpcMessageSender *sender_;&#10;</xsl:text>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>&#09;NanoRpc::IRpcClient *client_;&#10;</xsl:text>
				<xsl:text>&#09;NanoRpc::RpcObjectId object_id_;&#10;</xsl:text>
			</xsl:otherwise>
		</xsl:choose>

		<xsl:text>};&#10;&#10;&#10;</xsl:text>
	</xsl:template>

	<xsl:template match="xmlidl:property" >
		<!-- virtual SIMPLE_TYPE get_Property() const; -->
		<!-- virtual void get_Property( COMPLEX_TYPE *value ) const; -->
		<xsl:text>&#09;virtual </xsl:text>
		<xsl:call-template name="declare_return_type"/>
		<xsl:text> get_</xsl:text>
		<xsl:value-of select="@name" />
		<xsl:text>(</xsl:text>
		<xsl:call-template name="declare_return_argument"/>
		<xsl:text>) const;</xsl:text>
		<xsl:text>&#10;</xsl:text>

		<!-- 
			This is a not schema-aware processor, so we cannot rely on datatype of 
			attributes and elements declared in schema!
		-->
		<xsl:if test="count(@readonly)=0 or @readonly='false' or @readonly='no' or  @readonly='0'">
			<!-- virtual void set_Property( const TYPE & ); -->
			<xsl:text>&#09;virtual void</xsl:text>
			<xsl:text> set_</xsl:text>
			<xsl:value-of select="@name" />
			<xsl:text>( const </xsl:text>
			<xsl:call-template name="map_type" />
			<xsl:text> &amp; );</xsl:text>
			<xsl:text>&#10;</xsl:text>
		</xsl:if>
	</xsl:template>

	<xsl:template match="xmlidl:method" >
		<xsl:text>&#09;virtual </xsl:text>
		<xsl:call-template name="declare_method_return_type"/>
		<xsl:text> </xsl:text>
		<xsl:value-of select="@name" />
		<xsl:text>(</xsl:text>
		<xsl:apply-templates select="xmlidl:arguments" />
		<xsl:if test="count( xmlidl:returns ) != 0" >
			<xsl:call-template name="declare_return_argument">
				<xsl:with-param name="type" select="xmlidl:returns/@type"/>
			</xsl:call-template>
		</xsl:if>
		<xsl:text>);</xsl:text>
		<xsl:text>&#10;</xsl:text>
	</xsl:template>

	<xsl:template name="declare_method_return_type" >
		<xsl:choose>
			<xsl:when test="count( xmlidl:returns ) != 0" >
				<xsl:call-template name="declare_return_type" >
					<xsl:with-param name="type" select="xmlidl:returns/@type"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:text>void</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template name="declare_return_type" >
		<xsl:param name="type" select="@type"/>
		<xsl:choose>
			<xsl:when test="$type='bool' or $type='int' or $type='long' or $type='double'">
				<xsl:call-template name="map_type">
					<xsl:with-param name="type_to_map" select="$type"/>
				</xsl:call-template>
			</xsl:when>

			<xsl:when test="count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0">
				<xsl:value-of select="$type"/>
			</xsl:when>

			<xsl:when test="count( /xmlidl:idl/xmlidl:interfaces/xmlidl:interface[@name=$type] ) != 0">
				<xsl:value-of select="$type"/>
				<xsl:text>*</xsl:text>
			</xsl:when>

			<xsl:otherwise>
				<xsl:text>void</xsl:text>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>


	<xsl:template name="declare_return_argument" >
		<xsl:param name="type" select="@type"/>
		<xsl:if test="not( $type='bool' or $type='int' or $type='long' or $type='double' or
						count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0 or
						count( /xmlidl:idl/xmlidl:interfaces/xmlidl:interface[@name=$type] ) != 0 )">
			<xsl:if test="count( xmlidl:arguments/xmlidl:argument ) != 0">
				<xsl:text>, </xsl:text>
			</xsl:if>
			<xsl:call-template name="map_type" >
				<xsl:with-param name="type_to_map" select="$type" />
			</xsl:call-template>
			<xsl:text> *return_value</xsl:text>
		</xsl:if>
	</xsl:template>


	<xsl:template match="xmlidl:argument" >
		<xsl:call-template name="create_argument" />
		<xsl:if test="position() != last()">
			<xsl:text>, </xsl:text>
		</xsl:if>
	</xsl:template>


	<xsl:template name="create_argument" >
		<xsl:variable name="type" select="@type"/>
		<xsl:choose>
			<xsl:when test="@type='bool' or @type='int' or @type='long' or @type='double'">
				<xsl:call-template name="map_type" />
				<xsl:text> </xsl:text>
				<xsl:value-of select="@name" />
			</xsl:when>

			<xsl:when test="count( /xmlidl:idl/xmlidl:enumerations/xmlidl:enum[@name=$type] ) != 0">
				<xsl:value-of select="@type" />
				<xsl:text> </xsl:text>
				<xsl:value-of select="@name" />
			</xsl:when>

			<xsl:when test="@type = 'string'">
				<xsl:text>const </xsl:text>
				<xsl:call-template name="map_type" />
				<xsl:text> &amp;</xsl:text>
				<xsl:value-of select="@name" />
			</xsl:when>

			<xsl:otherwise>
				<xsl:text>const </xsl:text>
				<xsl:value-of select="@type" />
				<xsl:text> &amp;</xsl:text>
				<xsl:value-of select="@name" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

</xsl:stylesheet>

