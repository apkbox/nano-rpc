#include <string>

#include "google\protobuf\compiler\code_generator.h"
#include "google\protobuf\compiler\cpp\cpp_generator.h"
#include "google\protobuf\compiler\plugin.h"
#include "google\protobuf\compiler\plugin.pb.h"
#include "google\protobuf\io\coded_stream.h"
#include "google\protobuf\io\printer.h"
#include "google\protobuf\io\zero_copy_stream.h"
#include "google\protobuf\io\zero_copy_stream_impl_lite.h"
#include "google\protobuf\wrappers.pb.h"

#include "nanorpc/rpc_types.pb.h"

#include "nanorpc/compiler/cpp/generator_utils.h"
#include "nanorpc/compiler/cpp/code_model.h"

namespace pb = google::protobuf;
namespace pbc = google::protobuf::compiler;

std::string GetPropertySignature(const code_model::MethodModel *method,
                                 bool setter) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    const code_model::TypeModel &type =
        setter ? method->arguments().front().type() : method->return_type();

    vars["method_name"] = method->name();
    vars["type_name"] = type.name();

    if (type.is_reference_type()) {
      if (setter)
        printer.Print(vars, "void set_$method_name$(const $type_name$ &value)");
      else
        printer.Print(vars, "void get_$method_name$($type_name$ *value) const");
    } else {
      if (setter)
        printer.Print(vars, "void set_$method_name$($type_name$ value)");
      else
        printer.Print(vars, "$type_name$ get_$method_name$() const");
    }
  }

  return output;
}

std::string GetMethodSignature(const code_model::MethodModel &method,
                               const std::string &service_name) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["service_name_prefix"] = service_name.empty() ? "" : (service_name + "::");
    vars["method_name"] = method.name();
    vars["output_type_name"] = method.return_type().name();

    if (method.return_type().is_reference_type())
      printer.Print(vars, "void $service_name_prefix$$method_name$(");
    else
      printer.Print(vars, "$output_type_name$ $service_name_prefix$$method_name$(");

    for (size_t i = 0; i < method.arguments().size(); ++i) {
      const auto &arg = method.arguments()[i];

      std::map<std::string, std::string> vars;

      vars["arg_type"] = arg.type().name();
      vars["const"] = arg.type().is_reference_type() ? "const " : "";
      vars["reference"] = arg.type().is_reference_type() ? "&" : "";
      vars["arg_name"] = arg.name();
      printer.Print(vars, "$const$$arg_type$ $reference$$arg_name$");
      if ((i + 1) < method.arguments().size())
        printer.Print(", ");
    }

    if (method.return_type().is_reference_type()) {
      if (method.arguments().size() > 0)
        printer.Print(", ");
      printer.Print(vars, "$output_type_name$ *out__)");
    } else {
      printer.Print(")");
    }
  }

  return output;
}

std::string GetHeaderPrologue(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());
    vars["filename_base"] = StripProto(file->name());

    /* clang-format off */
    printer.Print(vars, "// Generated by the nanorpc protobuf plugin.\n");
    printer.Print(vars, "// If you make any local change, they will be lost.\n");
    printer.Print(vars, "// source: $filename$\n");
    printer.Print(vars, "#ifndef NANORPC_$filename_identifier$__INCLUDED\n");
    printer.Print(vars, "#define NANORPC_$filename_identifier$__INCLUDED\n");
    printer.Print(vars, "\n");
    printer.Print(vars, "#include \"$filename_base$.pb.h\"\n");
    printer.Print(vars, "#include \"nanorpc/rpc_client.hpp\"\n");
    printer.Print(vars, "#include \"nanorpc/rpc_stub.hpp\"\n");
    printer.Print(vars, "#include \"nanorpc/rpc_object_manager.hpp\"\n");
    printer.Print(vars, "\n");
    /* clang-format on */

    if (!file->package().empty()) {
      std::vector<std::string> parts = tokenize(file->package(), ".");

      for (auto &part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "namespace $part$ {\n");
      }

      printer.Print(vars, "\n");
    }
  }
  return output;
}

std::string GetInterfaceDefinitions(const std::vector<code_model::ServiceModel> &models) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    for (const auto &service_model : models) {
      vars["service_name"] = service_model.name();

      printer.Print(vars, "class $service_name$ {\n");
      printer.Print(vars, "public:\n");
      printer.Indent();
      printer.Print(vars, "virtual ~$service_name$() {}\n\n");

      for (const auto &method_model : service_model.methods()) {
        vars["method_name"] = method_model.name();
        if (method_model.is_property()) {
          if (method_model.getter() != nullptr)
            vars["getter_signature"] =
                GetPropertySignature(method_model.getter(), false);

          if (method_model.setter() != nullptr)
            vars["setter_signature"] =
                GetPropertySignature(method_model.setter(), true);

          printer.Print(vars, "virtual $getter_signature$ = 0;\n");
          printer.Print(vars, "virtual $setter_signature$ = 0;\n");
        } else {
          vars["method_signature"] = GetMethodSignature(method_model, std::string());
          printer.Print(vars, "virtual $method_signature$ = 0;\n");
        }
      }

      printer.Outdent();
      printer.Print(vars, "};\n\n");
    }
  }
  return output;
}

std::string GetStubDeclarations(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    for (int i = 0; i < file->service_count(); ++i) {
      const auto service = file->service(i);
      vars["service_name"] = service->name();

      /* clang-format off */
      printer.Print(vars, "class $service_name$_Stub : public nanorpc::IRpcStub {\n");
      printer.Print(vars, "public:\n");
      printer.Indent();
      printer.Print(vars, "explicit $service_name$_Stub(nanorpc::IRpcObjectManager* object_manager, $service_name$* impl)\n");
      printer.Print(vars, "    : object_manager_(object_manager), impl_(impl) {}\n\n");
      printer.Print(vars, "const char *GetInterfaceName() const;\n");
      printer.Print(vars, "void CallMethod(const nanorpc::RpcCall &rpc_call, nanorpc::RpcResult *rpc_result);\n\n");
      printer.Outdent();
      printer.Print(vars, "private:\n");
      printer.Indent();
      printer.Print(vars, "nanorpc::IRpcObjectManager* object_manager_;\n");
      printer.Print(vars, "$service_name$* impl_;\n");
      printer.Outdent();
      printer.Print(vars, "};\n\n");
      /* clang-format on */
    }
  }
  return output;
}

std::string GetProxyDeclarations(const std::vector<code_model::ServiceModel> &models) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    for (const auto &service_model : models) {
      vars["service_name"] = service_model.name();

      // TODO: Differentiate between _Proxy and _EventProxy
      //  - Event proxy has the following constructor
      //       .ctor(nanorpc::IRpcMessageSender *sender) : sender_( sender ) {}
      //  - Event proxy has empty destructor
      //  - Event proxy has one member
      //      nanorpc::IRpcMessageSender *sender_;
      printer.Print(vars, "class $service_name$_Proxy : public $service_name$ {\n");
      printer.Print(vars, "public:\n");
      printer.Indent();
      printer.Print(vars, "explicit $service_name$_Proxy(nanorpc::IRpcClient *client, nanorpc::RpcObjectId object_id = 0)\n");
      printer.Print(vars, "    : client_(client), object_id_(object_id) {}\n\n");
      
      printer.Print(vars, "virtual ~$service_name$_Proxy();\n\n");

      for (const auto &method_model : service_model.methods()) {
        vars["method_name"] = method_model.name();
        if (method_model.is_property()) {
          if (method_model.getter() != nullptr)
            vars["getter_signature"] =
                GetPropertySignature(method_model.getter(), false);

          if (method_model.setter() != nullptr)
            vars["setter_signature"] =
                GetPropertySignature(method_model.setter(), true);

          printer.Print(vars, "$getter_signature$ override;\n");
          printer.Print(vars, "$setter_signature$ override;\n");
        } else {
          vars["method_signature"] = GetMethodSignature(method_model, std::string());
          printer.Print(vars, "$method_signature$ override;\n");
        }
      }

      printer.Print(vars, "\n");

      printer.Outdent();
      printer.Print(vars, "private:\n");
      printer.Indent();
      printer.Print(vars, "nanorpc::IRpcClient *client_;\n");
      printer.Print(vars, "nanorpc::RpcObjectId object_id_;\n");
      printer.Outdent();
      printer.Print(vars, "};\n\n");
    }
  }
  return output;
}

std::string GetHeaderEpilogue(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());

    if (!file->package().empty()) {
      std::vector<std::string> parts = tokenize(file->package(), ".");

      for (auto &part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "}  // namespace $part$\n");
      }

      printer.Print(vars, "\n");
    }

    printer.Print(vars, "\n");
    printer.Print(vars, "#endif  // NANORPC_$filename_identifier$__INCLUDED\n");
  }
  return output;
}

std::string GetSourcePrologue(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());
    vars["filename_base"] = StripProto(file->name());

    /* clang-format off */
    printer.Print(vars, "// Generated by the nanorpc protobuf plugin.\n");
    printer.Print(vars, "// If you make any local change, they will be lost.\n");
    printer.Print(vars, "// source: $filename$\n");
    printer.Print(vars, "\n");
    printer.Print(vars, "#include \"$filename_base$.nanorpc.pb.h\"\n");
    printer.Print(vars, "#include \"google/protobuf/wrappers.pb.h\"\n");
    printer.Print(vars, "\n");
    /* clang-format on */

    if (!file->package().empty()) {
      std::vector<std::string> parts = tokenize(file->package(), ".");

      for (auto &part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "namespace $part$ {\n");
      }

      printer.Print(vars, "\n");
    }
  }
  return output;
}

void GenerateStubMethodCallImplementation(
    pb::io::Printer &printer,
    const code_model::MethodModel &method) {
  std::map<std::string, std::string> vars;

  vars["method_name"] = method.name();
  vars["return_type"] = method.return_type().name();
  vars["return_wrapper_name"] = method.return_type().wrapper_name();

  // Deserialize input arguments
  if (method.is_arglist()) {
    vars["arglist_typename"] = method.arglist_typename();
    printer.Print(vars, "$arglist_typename$ args__;\n");
    // BUG: This is incorrect if argument is a value type.
    // In order to parse it out one need to declare a PB wrapper first,
    // parse and then extract the value out of the wrapper.
    printer.Print(vars, "args__.ParseFromString(rpc_call.call_data());\n\n");

    // We can avoid declaring argument variable for value
    // types and instead pass them directly via message accessor, but
    // declaring them makes it easier to debug and they probably will
    // be optimized away anyways.
    for (size_t j = 0; j < method.arguments().size(); ++j) {
      const auto &arg = method.arguments()[j];
      vars["arg_name"] = arg.name();
      vars["arg_type"] = arg.type().name();
      vars["const"] = arg.type().is_reference_type() ? "const " : "";
      vars["ref"] = arg.type().is_reference_type() ? "&" : "";
      /* clang-format off */
      printer.Print(vars, "$const$$arg_type$ $ref$$arg_name$ = args__.$arg_name$();\n");
      /* clang-format on */
    }
  } else if (method.arguments().size() == 1) {
    const auto &arg = method.arguments()[0];

    // Declare wrapper variable for single argument calls and arglist calls.
    vars["arg_type"] = arg.type().wrapper_name();
    vars["arg_name"] = arg.name();
    printer.Print(vars, "$arg_type$ in_arg__;\n\n");

    vars["arg_type"] = arg.type().name();
    vars["const"] = arg.type().is_reference_type() ? "const " : "";
    vars["ref"] = arg.type().is_reference_type() ? "&" : "";
    printer.Print(vars, "in_arg__.ParseFromString(rpc_call.call_data());\n");
    if (arg.type().is_struct())
      printer.Print(vars, "$const$$arg_type$ &$arg_name$ = in_arg__;\n");
    else
      printer.Print(vars, "$const$$arg_type$ $ref$value = in_arg__.value();\n");
  }

  if (method.arguments().size() > 0)
    printer.Print(vars, "\n");

  // Define return type variable
  if (!method.return_type().is_void()) {
    printer.Print(vars, "$return_type$ out__;\n");
    if (!method.return_type().is_struct())
      printer.Print(vars, "$return_wrapper_name$ out_pb__;\n");
  }

  // Return for value types
  if (!method.return_type().is_void() &&
      !method.return_type().is_reference_type())
    printer.Print(vars, "out__ = ");

  // Call interface method
  printer.Print(vars, "impl_->$method_name$(");

  // Specify arguments
  for (size_t j = 0; j < method.arguments().size(); ++j) {
    const auto &arg = method.arguments()[j];
    vars["arg_name"] = arg.name();
    vars["arg_type"] = arg.type().name();
    printer.Print(vars, "$arg_name$");

    if ((j + 1) < method.arguments().size())
      printer.Print(vars, ", ");
  }

  // Specify return by pointer argument (for reference types)
  if (!method.return_type().is_void() &&
      method.return_type().is_reference_type()) {
    if (method.arguments().size() > 0)
      printer.Print(vars, ", ");
    printer.Print(vars, "&out__");
  }

  printer.Print(vars, ");\n");

  // Define result wrapper variable, wrap and serialize the result
  if (!method.return_type().is_void()) {
    printer.Print(vars, "\n");
    if (method.return_type().is_struct()) {
      /* clang-format off */
      printer.Print(vars, "out__.SerializeToString(rpc_result->mutable_result_data());\n");
      /* clang-format on */
    }
    else {
      /* clang-format off */
      printer.Print(vars, "out_pb__.set_value(out__);\n");
      printer.Print(vars, "out_pb__.SerializeToString(rpc_result->mutable_result_data());\n");
      /* clang-format on */
    }
  }
}

void GenerateStubImplementation(pb::io::Printer &printer,
                                const code_model::ServiceModel &service) {
  std::map<std::string, std::string> vars;

  printer.Indent();

  for (size_t i = 0; i < service.methods().size(); ++i) {
    const auto &method = service.methods()[i];
    vars["method_name"] = method.name();

    printer.Print(vars, "if (rpc_call.method() == \"$method_name$\") {\n");
    printer.Indent();
    GenerateStubMethodCallImplementation(printer, method);
    printer.Outdent();
    printer.Print(vars, "}");

    if ((i + 1) < service.methods().size())
      printer.Print(vars, " else ");
  }

  // TODO: Generate unknown method error, or return boolean indicating whether
  // the call succeeded.

  printer.Print(vars, "\n\n");
  printer.Outdent();
}

std::string GetStubDefinitions(
    const pb::FileDescriptor *file,
    const std::vector<code_model::ServiceModel> &models) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    for (const auto &service : models) {
      vars["service_name"] = service.name();
      vars["service_full_name"] = service.full_name();

      // clang-format off
      printer.Print(vars, "const char *$service_name$_Stub::GetInterfaceName() const {\n");
      printer.Indent();
      printer.Print(vars, "return \"$service_full_name$\";\n");
      printer.Outdent();
      printer.Print(vars, "}\n\n");

      printer.Print(vars, "void $service_name$_Stub::CallMethod(const nanorpc::RpcCall &rpc_call, nanorpc::RpcResult *rpc_result) {\n");
      GenerateStubImplementation(printer, service);
      printer.Print(vars, "}\n\n");
      // clang-format on
    }
  }
  return output;
}

void GenerateProxyMethodImplementation(pb::io::Printer &printer,
                                       const std::string &full_service_name,
                                       const code_model::MethodModel &method) {
  std::map<std::string, std::string> vars;

  vars["full_service_name"] = full_service_name;
  vars["method_name"] = method.name();
  vars["return_wrapper_name"] = method.return_type().wrapper_name();

  /* clang-format off */
  printer.Print(vars, "nanorpc::RpcMessage rpc_message__;\n");
  printer.Print(vars, "if (object_id_ != 0) {\n");
  printer.Indent();
  printer.Print(vars, "rpc_message__.mutable_call()->set_object_id(object_id_);\n");
  printer.Outdent();
  printer.Print(vars, "} else {\n");
  printer.Indent();
  printer.Print(vars, "rpc_message__.mutable_call()->set_service(\"$full_service_name$\");\n");
  printer.Outdent();
  printer.Print(vars, "}\n\n");

  printer.Print(vars, "rpc_message__.mutable_call()->set_method(\"$method_name$\");\n");
  /* clang-format on */

  // Serialize input arguments
  if (method.is_arglist()) {
    vars["arglist_typename"] = method.arglist_typename();
    printer.Print(vars, "$arglist_typename$ args__;\n");

    for (size_t j = 0; j < method.arguments().size(); ++j) {
      const auto &arg = method.arguments()[j];
      vars["arg_name"] = arg.name();
      /* clang-format off */
      if (arg.type().is_struct())
        printer.Print(vars, "*args__.mutable_$arg_name$() = $arg_name$;\n");
      else
        printer.Print(vars, "args__.set_$arg_name$($arg_name$);\n");
      /* clang-format on */
    }

    /* clang-format off */
    printer.Print(vars, "args__.SerializeToString(rpc_message__.mutable_call()->mutable_call_data());\n");
    printer.Print(vars, "\n");
    /* clang-format on */
  }
  else if (method.arguments().size() == 1) {
    const auto &arg = method.arguments()[0];

    // Declare wrapper variable for single argument calls and arglist calls.
    vars["arg_type"] = arg.type().wrapper_name();
    vars["arg_name"] = arg.name();
    if (arg.type().is_struct()) {
      printer.Print(vars, "const $arg_type$ &in_arg__ = value;\n\n");
    } else {
      printer.Print(vars, "$arg_type$ in_arg__;\n\n");
      printer.Print(vars, "in_arg__.set_$arg_name$(value);\n\n");
    }
    /* clang-format off */
    printer.Print(vars, "in_arg__.SerializeToString(rpc_message__.mutable_call()->mutable_call_data());\n");
    /* clang-format on */
  }

  printer.Print(vars, "nanorpc::RpcResult rpc_result__;\n");
  printer.Print(vars, "client_->SendWithReply(rpc_message__, &rpc_result__);\n");

  // Deserialize the result
  if (!method.return_type().is_void()) {
    if (method.return_type().is_struct()) {
      /* clang-format off */
      printer.Print(vars, "if (out__ != nullptr)\n");
      printer.Indent();
      printer.Print(vars, "out__->ParseFromString(rpc_result__.result_data());\n");
      printer.Outdent();
      /* clang-format on */
    } else if (method.return_type().is_reference_type()) {
      /* clang-format off */
      printer.Print(vars, "if (out__ != nullptr) {\n");
      printer.Indent();
      printer.Print(vars, "$return_wrapper_name$ out_pb__;\n");
      printer.Print(vars, "out_pb__.ParseFromString(rpc_result__.result_data());\n");
      printer.Print(vars, "*out__ = out_pb__.value();\n");
      printer.Outdent();
      printer.Print(vars, "}\n");
      /* clang-format on */
    } else {
      /* clang-format off */
      printer.Print(vars, "$return_wrapper_name$ out_pb__;\n");
      printer.Print(vars, "out_pb__.ParseFromString(rpc_result__.result_data());\n");
      printer.Print(vars, "return out_pb__.value();\n");
      /* clang-format on */
    }
  }
}

void GenerateProxyImplementation(pb::io::Printer &printer,
                                 const code_model::ServiceModel &service) {
  for (const auto &method : service.methods()) {
    std::map<std::string, std::string> vars;

    vars["method_name"] = method.name();
    vars["method_signature"] = GetMethodSignature(method, service.name() + "_Proxy");
    vars["return_type"] = "void";

    printer.Print(vars, "$method_signature$ {\n");
    printer.Indent();
    GenerateProxyMethodImplementation(printer, service.full_name(), method);
    printer.Outdent();
    printer.Print(vars, "}\n\n");
  }
}

std::string GetProxyDefinitions(const std::vector<code_model::ServiceModel> &models) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    for (const auto &service : models) {
      vars["service_name"] = service.name();
      vars["service_full_name"] = service.full_name();

      // clang-format off
      printer.Print(vars, "$service_name$_Proxy::~$service_name$_Proxy() {\n");
      printer.Indent();
      printer.Print(vars, "if (object_id_ != 0) {\n");
      printer.Indent();
      printer.Print(vars, "try {\n");
      printer.Indent();
      printer.Print(vars, "nanorpc::RpcMessage rpc_message;\n");
      printer.Print(vars, "rpc_message.mutable_call()->set_service(\"NanoRpc.ObjectManagerService\");\n");
      printer.Print(vars, "rpc_message.mutable_call()->set_method(\"Delete\");\n");
      printer.Print(vars, "nanorpc::RpcObject rpc_object;\n");
      printer.Print(vars, "rpc_object.set_object_id(object_id_);\n");
      printer.Print(vars, "rpc_object.SerializeToString(rpc_message.mutable_call()->mutable_call_data());\n");
      printer.Print(vars, "client_->Send(rpc_message);\n");
      printer.Outdent();
      printer.Print(vars, "}\n");
      printer.Print(vars, "catch (...) {\n");
      printer.Indent();
      printer.Print(vars, "// not yet supported\n");
      printer.Outdent();
      printer.Print(vars, "}\n");
      printer.Outdent();
      printer.Print(vars, "}\n");
      printer.Outdent();
      printer.Print(vars, "}\n\n");
      // clang-format on

      GenerateProxyImplementation(printer, service);
    }
  }
  return output;
}

std::string GetSourceEpilogue(const pb::FileDescriptor *file) {
  std::string output;
  {
    // Scope the output stream so it closes and finalizes output to the string.
    pb::io::StringOutputStream output_stream(&output);
    pb::io::Printer printer(&output_stream, '$');
    std::map<std::string, std::string> vars;

    vars["filename"] = file->name();
    vars["filename_identifier"] = FilenameIdentifier(file->name());

    if (!file->package().empty()) {
      std::vector<std::string> parts = tokenize(file->package(), ".");

      for (auto &part = parts.rbegin(); part != parts.rend(); part++) {
        vars["part"] = *part;
        printer.Print(vars, "}  // namespace $part$\n");
      }

      printer.Print(vars, "\n");
    }

    printer.Print(vars, "\n");
  }
  return output;
}
